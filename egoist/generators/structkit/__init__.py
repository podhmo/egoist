from __future__ import annotations
import typing as t

import logging
import pathlib
import contextlib
from egoist.app import App
from egoist import types
from egoist.langhelpers import get_path_from_function_name, get_fullname_of_callable


if t.TYPE_CHECKING:
    from egoist.runtime import Env
    from egoist.internal.prestringutil import Module
    from egoist.go.resolver import Resolver

logger = logging.getLogger(__name__)


def walk(fns: t.Dict[str, types.Command], *, root: t.Union[str, pathlib.Path]) -> None:
    from egoist.components.fs import open_fs

    with open_fs(root=root) as fs:
        for name, fn in fns.items():
            logger.debug("walk %s", name)
            fpath = f"{get_path_from_function_name(name)}.go"
            with fs.open_file_with_tracking(fpath, "w", target=fn) as env:
                fn()

                if env.generated is None:
                    logger.warn(
                        "%s(), runtime.generate() is not called, please use it",
                        get_fullname_of_callable(fn),
                    )


@contextlib.contextmanager
def structkit(
    env: Env,
    classes: t.List[t.Type[t.Any]],
    dry_run: bool,
    *,
    resolver: t.Optional[Resolver] = None,
) -> t.Iterator[Module]:
    if dry_run:
        logger.debug("dry run, %s skipped", __name__)
        yield env.m
        return

    from egoist.go.types import get_gopackage
    from egoist.go.walker import get_walker
    from egoist.generators.structkit import _emit
    from . import runtime

    m = env.m
    w = get_walker(classes, m=m, metadata_handler=runtime._default_metadata_handler)

    yield m
    m.import_("")
    m.stmt(f"// this file is generated by {__name__}")
    m.sep()

    for item in w.walk():
        gopackage = get_gopackage(item.type_)
        if gopackage is not None:
            continue

        if item.is_enums:
            _emit.emit_enums(w, item.type_)
            m.sep()
        elif item.is_union:
            _emit.emit_union(w, item)
            m.sep()
        else:
            _emit.emit_struct(w, item)
            m.sep()
            if item.fields:
                _emit.emit_unmarshalJSON(w, item)
            m.sep()


def includeme(app: App) -> None:
    app.include("egoist.components.fs")
